#!/bin/bash
###############################################################################
##
# FILE:         dateex
# PRODUCT:      tools
# AUTHOR:       /^--
# DATE CREATED: 05-Jan-2012
#
###############################################################################
# CONTENTS:
#   Extended human date specifications for the "date" command.
#   Also understands shortcuts [+-]N[dwmy].
#
# DEPENDENCIES:
#   - Perl Date::Manip package.
#
# REMARKS:
#
# FILE_SCCS = "@(#)dateex       007     (15-Dec-2012)   tools";
#
# REVISION      DATE            REMARKS
#       007	15-Dec-2012	BUG: When preprocessing "next month", must add
#                               the resulting year; otherwise crossing of the
#                               year end won't be considered and a past month in
#                               the current year will be used.
#       006	19-Nov-2012	FIX: When Date::Manip isn't available, the "in
#                               * month / year" preprocessing never works. Move
#                               the defaulting to the original date into the
#                               parseDate() function.
#                               When Date::Manip isn't available and the
#                               default date command barfs on the untransformed
#                               date format, no indication is shown. Store the
#                               error output from the Perl invocation and show
#                               it in case of an eventual date error.
#	005	23-Jun-2012	Allow interpretation of "next Friday in next
#				month".
#       004     18-Apr-2012     ENH: Apply preprocessing of shortcuts not just
#                               on the whole date, but on individual words, to
#                               allow shortcuts in timespans "2012-04-18 -2d".
#                               This is useful in todo.sh did 42 after 2d.
#       003     13-Apr-2012     FIX: Short-circuit if no date was passed, i.e.
#                               the current date should be used.
#       002     22-Feb-2012     ENH: Also understand shortcuts [+-]N[dwmy].
#       001     05-Jan-2012     file creation
###############################################################################

shopt -qs extglob

typeset -a allargs=()
while [ $# -ne 0 ]
do
    case "$1" in
        --date|-d)  shift; date=$1; shift;;
        --date=*)   date=${1#--date=}; shift;;
        -d=*)       date=${1#-d=}; shift;;
        --date*)    date=${1#--date}; shift;;
        -d*)        date=${1#-d}; shift;;
        *)          allargs+=("$1"); shift;;
    esac
done

# Short-circuit if no date was passed, i.e. the current date should be used.
# This not only avoids unnecessary processing, but date actually behaves
# different when an empty date is passed:
#   $ date --date '' +%F_%H%M%S
#   2012-04-13_000000
#   $ date +%F_%H%M%S
#   2012-04-13_141147
[ "$date" ] || exec date "${allargs[@]}"

parseError=
# The Perl Date::Manip library understands many human date specifications that
# /usr/bin/date does not.
parseDate()
{
    if ! parsedDate=$(perl -e '
use strict;
use Date::Manip;

print UnixDate($ARGV[0], "'"$1"'");
' "$2" 2>&1); then
        # Without Date::Manip support, we'll just fall back to the normal date
        # specifications, but store the error output so it can be shown should
        # the default date command barf on the untransformed date format.
        parseError=$parsedDate
        parsedDate=$2
    fi
}


# Allow some additional shortcuts that are quite handy.
# Since we transform into the common format, this does not depend on the Perl
# processing, so we do it in the shell wrapper.
preprocDate=
for word in $date
do
    case $word in
        ?(+)+([0-9])d)  word="${word//[^0-9]/} days";;
        ?(+)+([0-9])w)  word="${word//[^0-9]/} weeks";;
        ?(+)+([0-9])m)  word="${word//[^0-9]/} months";;
        ?(+)+([0-9])y)  word="${word//[^0-9]/} years";;
        -+([0-9])d)     word="${word//[^0-9]/} days ago";;
        -+([0-9])w)     word="${word//[^0-9]/} weeks ago";;
        -+([0-9])m)     word="${word//[^0-9]/} months ago";;
        -+([0-9])y)     word="${word//[^0-9]/} years ago";;
    esac
    preprocDate=${preprocDate}${preprocDate:+ }${word}
done

# Date::Manip understands "next Friday in July", but not "next Friday in next
# month".
case $preprocDate in
    *\ in\ *month*) parseDate '%B %Y' "${preprocDate##* in }"; preprocDate="${preprocDate% in *} in $parsedDate";;
    *\ in\ *year*)  parseDate    '%Y' "${preprocDate##* in }"; preprocDate="${preprocDate% in *} in $parsedDate";;
esac

parseDate '%Y-%m-%d %H:%M:%S' "$preprocDate"
unset -f date # The original date might have been overridden with this extended version; avoid an infinite recursion by unsetting any function wrapper.
date --date "$parsedDate" "${allargs[@]}" || {
    exitStatus=$?
        printf >&2 '%s\n' "$parseError"
    exit $exitStatus
}
