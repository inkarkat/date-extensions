#!/bin/bash
###############################################################################
##
# FILE:         dateex
# PRODUCT:      tools
# AUTHOR:       /^--
# DATE CREATED: 05-Jan-2012
#
###############################################################################
# CONTENTS:
#   Extended human date specifications for the "date" command.
#   Also understands shortcuts [+-]N[dwmy].
#
# DEPENDENCIES:
#   - Perl Date::Manip package.
#
# REMARKS:
#
# FILE_SCCS = "@(#)dateex       009     (05-Feb-2016)   tools";
#
# REVISION      DATE            REMARKS
#       009	05-Feb-2016	ENH: Also handle "date OR date [OR date]" by
#                               splitting into individual dates, parsing each,
#                               and then choosing the one closest to now.
#                               Refactoring: Extract convertDate() and
#                               transformDate().
#       008     21-Jan-2013     BUG: When Date::Manip does not understand the
#                               passed date (e.g. "@hp" or "foobar"), it returns
#                               an empty string and status 0, causing the
#                               fallback Unix date command to use the current
#                               date instead of issuing an error. Need to revert
#                               to the passed date.
#       007     15-Dec-2012     BUG: When preprocessing "next month", must add
#                               the resulting year; otherwise crossing of the
#                               year end won't be considered and a past month in
#                               the current year will be used.
#       006     19-Nov-2012     FIX: When Date::Manip isn't available, the "in
#                               * month / year" preprocessing never works. Move
#                               the defaulting to the original date into the
#                               parseDate() function.
#                               When Date::Manip isn't available and the
#                               default date command barfs on the untransformed
#                               date format, no indication is shown. Store the
#                               error output from the Perl invocation and show
#                               it in case of an eventual date error.
#       005     23-Jun-2012     Allow interpretation of "next Friday in next
#                               month".
#       004     18-Apr-2012     ENH: Apply preprocessing of shortcuts not just
#                               on the whole date, but on individual words, to
#                               allow shortcuts in timespans "2012-04-18 -2d".
#                               This is useful in todo.sh did 42 after 2d.
#       003     13-Apr-2012     FIX: Short-circuit if no date was passed, i.e.
#                               the current date should be used.
#       002     22-Feb-2012     ENH: Also understand shortcuts [+-]N[dwmy].
#       001     05-Jan-2012     file creation
###############################################################################

shopt -qs extglob

typeset -a allargs=()
while [ $# -ne 0 ]
do
    case "$1" in
        --date|-d)  shift; date=$1; shift;;
        --date=*)   date=${1#--date=}; shift;;
        -d=*)       date=${1#-d=}; shift;;
        --date*)    date=${1#--date}; shift;;
        -d*)        date=${1#-d}; shift;;
        *)          allargs+=("$1"); shift;;
    esac
done

# Short-circuit if no date was passed, i.e. the current date should be used.
# This not only avoids unnecessary processing, but date actually behaves
# different when an empty date is passed:
#   $ date --date '' +%F_%H%M%S
#   2012-04-13_000000
#   $ date +%F_%H%M%S
#   2012-04-13_141147
[ "$date" ] || exec date "${allargs[@]}"

parseError=
# The Perl Date::Manip library understands many human date specifications that
# /usr/bin/date does not.
parseDate()
{
    if parsedDate=$(perl -e '
use strict;
use Date::Manip;

print UnixDate($ARGV[0], "'"$1"'");
' "$2" 2>&1); then
        if [ -z "$parsedDate" ]; then
            # When Date::Manip does not understand the passed date, it returns
            # an empty string. Though unlikely, let's revert to the passed date
            # and let the Unix date command have another try (and create the
            # proper error message).
            parsedDate=$2
        fi
    else
        # Without Date::Manip support, we'll just fall back to the normal date
        # specifications, but store the error output so it can be shown should
        # the default date command barf on the untransformed date format.
        parseError=$parsedDate
        parsedDate=$2
    fi
}

unset -f date # The original date might have been overridden with this extended version; avoid an infinite recursion by unsetting any function wrapper.
convertDate()
{
    date --date "$@"
}

transformDate()
{
    # Allow some additional shortcuts that are quite handy.
    # Since we transform into the common format, this does not depend on the Perl
    # processing, so we do it in the shell wrapper.
    preprocDate=
    for word in $date
    do
        case $word in
            ?(+)+([0-9])d)  word="${word//[^0-9]/} days";;
            ?(+)+([0-9])w)  word="${word//[^0-9]/} weeks";;
            ?(+)+([0-9])m)  word="${word//[^0-9]/} months";;
            ?(+)+([0-9])y)  word="${word//[^0-9]/} years";;
            -+([0-9])d)     word="${word//[^0-9]/} days ago";;
            -+([0-9])w)     word="${word//[^0-9]/} weeks ago";;
            -+([0-9])m)     word="${word//[^0-9]/} months ago";;
            -+([0-9])y)     word="${word//[^0-9]/} years ago";;
        esac
        preprocDate=${preprocDate}${preprocDate:+ }${word}
    done

    # Date::Manip understands "next Friday in July", but not "next Friday in next
    # month".
    case $preprocDate in
        *\ in\ *month*) parseDate '%B %Y' "${preprocDate##* in }"; preprocDate="${preprocDate% in *} in $parsedDate";;
        *\ in\ *year*)  parseDate    '%Y' "${preprocDate##* in }"; preprocDate="${preprocDate% in *} in $parsedDate";;
    esac

    parseDate '%Y-%m-%d %H:%M:%S' "$preprocDate"
    convertDate "$parsedDate" "$@" || {
        exitStatus=$?
            printf >&2 '%s\n' "$parseError"
        return $exitStatus
    }
}

handleDateAlternatives()
{
    local IFS=$'\n'
    typeset -a dates=(${date// or /$'\n'})
    typeset -a times
    for date in "${dates[@]}"
    do
        times+=($(transformDate '+%s')) || return $?
    done
#****D echo "**** ${times[*]}"

    # Select time nearest to now.
    now=$(date +%s)
    nearest=2147483647
    nearestDiff=$nearest
    for time in "${times[@]}"
    do
        ((diff = time - now))
        if [ ${diff#-} -lt ${nearestDiff#-} ]; then
            nearest=$time
            ((nearestDiff = nearest - now))
        fi
    done
#****D echo "**** $nearest"

    date="@${nearest}"  # @{number} is date's notation for Unix epoch.
}

case "$date" in
    *\ or\ *)   handleDateAlternatives && convertDate "$date" "${allargs[@]}";;
    *)          transformDate "${allargs[@]}";;
esac
