#!/bin/bash
###############################################################################
##
# FILE:         dateex
# PRODUCT:      tools
# AUTHOR:       /^--
# DATE CREATED: 05-Jan-2012
#
###############################################################################
# CONTENTS:
#   Extended human date specifications for the "date" command.
#   Also understands shortcuts [+-]N[dwmy].
#
# DEPENDENCIES:
#   - Perl Date::Manip package.
#
# REMARKS:
#
# FILE_SCCS = "@(#)dateex       005     (23-Jun-2012)   tools";
#
# REVISION      DATE            REMARKS
#	005	23-Jun-2012	Allow interpretation of "next Friday in next
#				month".
#       004     18-Apr-2012     ENH: Apply preprocessing of shortcuts not just
#                               on the whole date, but on individual words, to
#                               allow shortcuts in timespans "2012-04-18 -2d".
#                               This is useful in todo.sh did 42 after 2d.
#       003     13-Apr-2012     FIX: Short-circuit if no date was passed, i.e.
#                               the current date should be used.
#       002     22-Feb-2012     ENH: Also understand shortcuts [+-]N[dwmy].
#       001     05-Jan-2012     file creation
###############################################################################

shopt -qs extglob

typeset -a allargs=()
while [ $# -ne 0 ]
do
    case "$1" in
        --date|-d)  shift; date=$1; shift;;
        --date=*)   date=${1#--date=}; shift;;
        -d=*)       date=${1#-d=}; shift;;
        --date*)    date=${1#--date}; shift;;
        -d*)        date=${1#-d}; shift;;
        *)          allargs+=("$1"); shift;;
    esac
done

# Short-circuit if no date was passed, i.e. the current date should be used.
# This not only avoids unnecessary processing, but date actually behaves
# different when an empty date is passed:
#   $ date --date '' +%F_%H%M%S
#   2012-04-13_000000
#   $ date +%F_%H%M%S
#   2012-04-13_141147
[ "$date" ] || exec date "${allargs[@]}"

# The Perl Date::Manip library understands many human date specifications that
# /usr/bin/date does not.
parseDate()
{
perl -e '
use strict;
use Date::Manip;

print UnixDate($ARGV[0], "'"$1"'");
' "$2" 2>/dev/null
}


# Allow some additional shortcuts that are quite handy.
# Since we transform into the common format, this does not depend on the Perl
# processing, so we do it in the shell wrapper.
preprocDate=
for word in $date
do
    case $word in
        ?(+)+([0-9])d)  word="${word//[^0-9]/} days";;
        ?(+)+([0-9])w)  word="${word//[^0-9]/} weeks";;
        ?(+)+([0-9])m)  word="${word//[^0-9]/} months";;
        ?(+)+([0-9])y)  word="${word//[^0-9]/} years";;
        -+([0-9])d)     word="${word//[^0-9]/} days ago";;
        -+([0-9])w)     word="${word//[^0-9]/} weeks ago";;
        -+([0-9])m)     word="${word//[^0-9]/} months ago";;
        -+([0-9])y)     word="${word//[^0-9]/} years ago";;
    esac
    preprocDate=${preprocDate}${preprocDate:+ }${word}
done

# Date::Manip understands "next Friday in July", but not "next Friday in next
# month".
case $preprocDate in
    *\ in\ *month*) preprocDate="${preprocDate% in *} in $(parseDate '%B' "${preprocDate##* in }")";;
    *\ in\ *year*)  preprocDate="${preprocDate% in *} in $(parseDate '%Y' "${preprocDate##* in }")";;
esac

parsedDate=$(parseDate '%Y-%m-%d %H:%M:%S' "$preprocDate")
[ "$parsedDate" ] || parsedDate=$preprocDate
exec date --date "$parsedDate" "${allargs[@]}"
